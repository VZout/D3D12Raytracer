#ifndef GPU
#pragma once
#endif

#include "rt_structs.hlsl"

//#define REFLECTIONS
#define REFLECTION_RECURSION 0

#ifdef GPU
Texture2D in_texture : register(t0);
SamplerState s0 : register(s0);

struct VS_OUTPUT
{
	float4 pos : SV_POSITION;
	float2 uv : TEXCOORD;
};
#endif

// ##################################
#ifdef GPU

struct Light
{
	int type;
	float intensity;
	float3 position;
	float3 direction;
};

struct Sphere
{
	float3 center;
	float radius;
	float3 color;
	float intensity;
};

constant int num_spheres = 1;
static Sphere spheres[num_spheres];

#ifndef GPU
static float2 canvas_size(600, 600);
static float viewport_size = 1;
static float epsilon = 0.08;
static float3 camera_pos(0, 0, -3);
static float z_near = 1;
static float3 sky_color(0, 0, 0);
static float3 floor_color(1, 1, 1);
static float gamma = 1;
static float exposure = 1;
#endif

static float2 seeder;

struct Intersection
{
	Triangle closest;
	float closest_t;
};

struct SphereIntersection
{
	Sphere closest;
	float closest_t;
};

static const float inf = 9999999;

Triangle MakeNull()
{
	Triangle retval;
	retval.a.x = -inf;
	return retval;
}

// Load three 16 bit indices from a byte addressed buffer.
uint3 Load3x16BitIndices(uint offsetBytes)
{
    uint3 retval;

    // ByteAdressBuffer loads must be aligned at a 4 byte boundary.
    // Since we need to read three 16 bit indices: { 0, 1, 2 } 
    // aligned at a 4 byte boundary as: { 0 1 } { 2 0 } { 1 2 } { 0 1 } ...
    // we will load 8 bytes (~ 4 indices { a b | c d }) to handle two possible index triplet layouts,
    // based on first index's offsetBytes being aligned at the 4 byte boundary or not:
    //  Aligned:     { 0 1 | 2 - }
    //  Not aligned: { - 0 | 1 2 }
    const uint dwordAlignedOffset = offsetBytes & ~3;    
    const uint2 four16BitIndices = indices.Load2(dwordAlignedOffset);
 
    // Aligned: { 0 1 | 2 - } => retrieve first three 16bit indices
    if (dwordAlignedOffset == offsetBytes)
    {
        retval.x = four16BitIndices.x & 0xffff;
        retval.y = (four16BitIndices.x >> 16) & 0xffff;
        retval.z = four16BitIndices.y & 0xffff;
    }
    else // Not aligned: { - 0 | 1 2 } => retrieve last three 16bit indices
    {
        retval.x = (four16BitIndices.x >> 16) & 0xffff;
        retval.y = four16BitIndices.y & 0xffff;
        retval.z = (four16BitIndices.y >> 16) & 0xffff;
    }

    return retval;
}

float3 RandomSpherePoint(Sphere sphere, float u, float v){
	static const float PI = 3.14159265f;
	float theta = 2 * PI * u;
	float phi = acos(2 * v - 1);
	float x = sphere.center.x + (sphere.radius * sin(phi) * cos(theta));
	float y = sphere.center.y + (sphere.radius * sin(phi) * sin(theta));
	float z = sphere.center.z + (sphere.radius * cos(phi));
	return float3(x, y, z);	
}

bool IsNull(Triangle tri)
{
	return tri.a.x == -inf;
}

constant int num_lights = 2;
static Light lights[num_lights];

FUNC Material GetMaterial(int idx)
{
	return materials[idx];
}

FUNC float3 CanvasToViewport(float2 pos)
{
	return float3(pos.x * viewport_size / canvas_size.x,
		pos.y * viewport_size / canvas_size.y,
		z_near);
}

Intersection ClosestIntersection(float3 origin, float3 direction, float min_t, float max_t);
float3 ReflectRay(float3 v1, float3 v2);

#define AMBIENT 0
#define POINT 1

FUNC float random( float2 p )
{
    float2 K1 = float2(
        23.14069263277926, // e^pi (Gelfond's constant)
         2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)
    );
    return frac( cos( dot(p,K1) ) * 12345.6789 );
}

FUNC float3 ComputeLighting(float3 pont, float3 N, float3 V, Material material, float max_t)
{
	const int num_samples = 75;
	float intensities[num_samples];
	float intensity = 0;
	const float length_n = length(N);
	const float length_v = length(V);


	[unroll(num_spheres)]
	for (int i = 0; i < num_spheres; i++)
	{
		//Light light = lights[i];
		Sphere slight = spheres[i];
		/*if (light.type == AMBIENT)
		{
			intensity += light.intensity;
			continue;
		}*/

		for (int p = 0; p < num_samples; p++)
		{
			float3 vec_l;
			//if (light.type == POINT)
			{
				//vec_l = slight.center - pont;
				//vec_l = RandomSpherePoint(slight, randoms[floor((p) % 500)], randoms[floor((p + 100) % 500)]) - pont;
				vec_l = RandomSpherePoint(slight, random(float2(pont.x + pont.z, pont.y + pont.z) * p) % 1, random(float2(N.x + N.z, N.y + N.z) / p) % 1) - pont;
				max_t = 1.0f;
			}
			/*else // Light.DIRECTIONAL
			{
				vec_l = light.position;
			}*/

			// Shadow check
			const Intersection intersect = ClosestIntersection(pont, vec_l, epsilon, max_t);
			if (!IsNull(intersect.closest))
			{
				intensities[p] = 0;
				continue;
			}

			// Diffuse
			const float n_dot_l = dot(N, vec_l);
			if (n_dot_l > 0)
			{
				intensity += slight.intensity * n_dot_l / (length_n * length(vec_l));
				//intensity += light.intensity * n_dot_l;
			}

			if (material.specular != -1)
			{
				const float3 vec_r = ReflectRay(vec_l, N);
				//const float3 vec_r = mul(2.0*dot(N, vec_l), N) - vec_l;
				const float r_dot_v = dot(vec_r, V);
				if (r_dot_v > 0)
				{
					intensity += slight.intensity * pow(r_dot_v / (length(vec_r) * length_v), material.specular);
				}
			}

			intensities[p] = intensity;
		}
	}

	intensity = intensity / num_samples;


	return float3(intensity, intensity, intensity);
}

FUNC float2 IntersectRaySphere(float3 origin, float3 direction, Sphere sphere)
{
	float3 oc = origin - sphere.center;

	float k1 = dot(direction, direction);
	float k2 = 2 * dot(oc, direction);
	float k3 = dot(oc, oc) - sphere.radius * sphere.radius;

	float discriminant = k2 * k2 - 4.f * k1 * k3;
	if (discriminant < 0)
	{
		return float2(inf, inf);
	}

	float t1 = (-k2 + sqrt(discriminant)) / (2.f * k1);
	float t2 = (-k2 - sqrt(discriminant)) / (2.f * k1);

	return float2(t1, t2);
}


FUNC float2 IntersectRayTriangle(float3 orig, float3 dir, Triangle tri) 
{ 
   	const float3 v0v1 = tri.b - tri.a; 
    const float3 v0v2 = tri.c - tri.a; 
    const float3 pvec = cross(dir, v0v2); 
    const float det = dot(v0v1, pvec); 
 
    // ray and triangle are parallel if det is close to 0
    if (abs(det) < epsilon) return float2(inf, inf); 
 
    const float invDet = 1 / det; 
 
    const float3 tvec = orig - tri.a; 
    const float u = dot(tvec, pvec) * invDet; 
    if (u < 0 || u > 1) return float2(inf, inf); 
 
    const float3 qvec = cross(tvec, v0v1); 
    const float v = dot(dir, qvec) * invDet; 
    if (v < 0 || u + v > 1) return float2(inf, inf); 
 
    const float t = dot(v0v2, qvec) * invDet; 
 
    return (t > 0) ? float2(t, t) : float2(inf, inf); 
} 

FUNC Intersection ClosestIntersection(float3 origin, float3 direction, float min_t, float max_t)
{
	float closest_t = inf;
	Triangle closest_triangle = MakeNull();

	[unroll(num_indices/3)]
	for (int i = 0; i < num_indices; i += 3)
	{
		const uint3 tri_vertices = Load3x16BitIndices(i*2);
		const Vertex v0 = vertices[tri_vertices.x];
		const Vertex v1 = vertices[tri_vertices.y];
		const Vertex v2 = vertices[tri_vertices.z];

		Triangle tri;
		tri.a = v0.position;
		tri.b = v1.position;
		tri.c = v2.position;
		tri.normal = v0.normal;
		tri.material_idx = v1.material_idx;
		

		const float2 ts = IntersectRayTriangle(origin, direction, tri);
		if (ts[0] < closest_t && ts[0] > min_t && ts[0] < max_t)
		{
			closest_t = ts[0];
			closest_triangle = tri;
		}
		if (ts[1] < closest_t && ts[1] > min_t && ts[1] < max_t)
		{
			closest_t = ts[1];
			closest_triangle = tri;
		}
	}

	Intersection retval;
	retval.closest = closest_triangle;
	retval.closest_t = closest_t;

	return retval;
}

FUNC float3 ReflectRay(float3 v1, float3 v2)
{
	return (v2 * ((2.f * dot(v1, v2))) - v1);
}

struct OutRef
{
	float3 ref_color;
	float3 ref_ray;
	float3 ref_point;
	float3 l_color;
	float metal;
	bool end;
};

FUNC float3 RecursiveTraceRay(float3 origin, float3 direction, float min_t, float max_t, int depth)
{
#ifdef REFLECTIONS
	float3 reflected_color;
	float3 reflected_ray = direction;

	OutRef refs[REFLECTION_RECURSION];

	[unroll(REFLECTION_RECURSION)]
	while (depth-- > 0)
	{
		Intersection intersect = ClosestIntersection(origin, reflected_ray, min_t, max_t);
		Triangle closest_triangle = intersect.closest;
		const float closest_t = intersect.closest_t;

		if (IsNull(closest_triangle))
		{
			reflected_color = sky_color;

			refs[depth].ref_color = reflected_color;
			refs[depth].ref_ray = reflected_ray;
			refs[depth].ref_point = origin;
			refs[depth].l_color = reflected_color;
			refs[depth].end = true;
			continue;
		}

		const float3 P = origin + (reflected_ray * closest_t);
		const float3 N = normalize(closest_triangle.normal);

		const float3 view = reflected_ray * -1.f;

		const Material material = GetMaterial(closest_triangle.material_idx);

		const float3 lighting = ComputeLighting(P, N, view, material, inf);
		const float3 local_color = material.color * lighting;

		if (material.metal <= 0 || depth <= 0)
		{
			reflected_color = local_color;

			refs[depth].ref_color = reflected_color;
			refs[depth].ref_ray = reflected_ray;
			refs[depth].ref_point = P;
			refs[depth].l_color = local_color;
			refs[depth].metal = material.metal;
			refs[depth].end = true;
			continue;
		}

		origin = P;
		reflected_ray = ReflectRay(view, N);

		refs[depth].ref_color = reflected_color;
		refs[depth].ref_ray = reflected_ray;
		refs[depth].ref_point = P;
		refs[depth].l_color = local_color;
		refs[depth].metal = material.metal;
		refs[depth].end = false;
	}

	float3 result = refs[REFLECTION_RECURSION - 1].ref_color;
	[unroll(REFLECTION_RECURSION)]
	for (int i = 0; i < REFLECTION_RECURSION; i++)
	{
		if (!refs[i].end)
		{
			result = (refs[i].l_color * (1.f - refs[i].metal)) + (result * refs[i].metal);
		}
		else
		{
			result = refs[i].ref_color;
		}
	}

	return result;
#else
	return sky_color;
#endif
}

FUNC float3 TraceRay(float3 origin, float3 direction, float min_t, float max_t, int depth)
{

	const Intersection intersect = ClosestIntersection(origin, direction, min_t, max_t);
	const Triangle closest_triangle = intersect.closest;
	const float closest_t = intersect.closest_t;

	if (IsNull(closest_triangle))
		return sky_color;

	const float3 P = origin + (direction * closest_t);
	const float3 N = normalize(closest_triangle.normal);

	const float3 view = direction * -1.f;

	const Material material = GetMaterial(closest_triangle.material_idx);

	const float3 lighting = ComputeLighting(P, N, view, material, inf);
	const float3 local_color = material.color * lighting;

#ifndef REFLECTIONS
	return local_color;
#else
	if (material.metal <= 0 || depth <= 0)
	{
		return local_color;
	}

	const float3 reflected_ray = ReflectRay(view, N);
	const float3 result = RecursiveTraceRay(P, reflected_ray, epsilon, inf, depth);

	return (local_color * (1.f - material.metal)) + (result * material.metal);
#endif
}

#ifdef GPU
float4 main(VS_OUTPUT input) : SV_TARGET
#else
FUNC float4 PixelTrace(Input input)
#endif
{
#ifdef GPU
	if (use_cpu)
	{
		float4 color = in_texture.Sample(s0, input.uv);
		return float4(color);
	}
#endif


	spheres[0].center = float3(0, 2, 1);
	spheres[0].color = float3(1, 0, 0);
	spheres[0].radius = 0.5;
	spheres[0].intensity = 1;
	//spheres[0].specular = 0;
	//spheres[0].metal = 01;

	lights[0].position = float3(0, 0, 3);
	lights[0].intensity = 0.2;
	lights[0].type = 0;
	lights[1].position = float3(0, 2, 0);
	lights[1].intensity = 0.8;
	lights[1].type = 1;

#ifdef GPU
	const float2 pixel_pos = {(input.pos.x - (canvas_size.x / 2)), (input.pos.y - (canvas_size.y / 2)) * -1};
#else
	const float2 pixel_pos = {input.pos.x, input.pos.y};
#endif

	seeder = pixel_pos;

	/*const float pixel_size = 0.25;
	const float3 dir0 = CanvasToViewport(pixel_pos - float2(-pixel_size, -pixel_size));
	const float3 dir1 = CanvasToViewport(pixel_pos - float2(-pixel_size, pixel_size));
	const float3 dir2 = CanvasToViewport(pixel_pos - float2(pixel_size, -pixel_size));
	const float3 dir3 = CanvasToViewport(pixel_pos - float2(pixel_size, pixel_size));

	const float3 color0 = TraceRay(camera_pos, dir0, z_near, inf, REFLECTION_RECURSION);
	const float3 color1 = TraceRay(camera_pos, dir1, z_near, inf, REFLECTION_RECURSION);
	const float3 color2 = TraceRay(camera_pos, dir2, z_near, inf, REFLECTION_RECURSION);
	const float3 color3 = TraceRay(camera_pos, dir3, z_near, inf, REFLECTION_RECURSION);
	float3 color = (color0 + color1 + color2 + color3) / 4;*/
	
	const float3 dir = CanvasToViewport(pixel_pos);
	float3 color = TraceRay(camera_pos, dir, z_near, inf, REFLECTION_RECURSION);

	color = clamp(color * exposure, 0.f, 1.f);
	color.x = pow(color.x, 1.f / gamma);
	color.y = pow(color.y, 1.f / gamma);
	color.z = pow(color.z, 1.f / gamma);

	//return float4(indices[0].index, 0, 0, 1.f);
	return float4(color.x, color.y, color.z, 1.f);
}
// ##################################
#endif


#ifndef GPU
#undef float3
#undef float2
#undef float4
#undef constant
#undef cbuffer
#undef length(v) {}
#undef dot(a, b) {}
#undef normalize(a) {}
#undef clamp

#undef AMBIENT
#undef POINT
#undef FUNC
#endif
