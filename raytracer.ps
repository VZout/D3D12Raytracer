#ifndef GPU
#pragma once
#endif

#include "rt_structs.hlsl"

//#define REFLECTIONS
#define REFLECTION_RECURSION 0

#ifdef GPU
Texture2D in_texture : register(t0);
SamplerState s0 : register(s0);

struct VS_OUTPUT
{
	float4 pos : SV_POSITION;
	float2 uv : TEXCOORD;
};
#endif

// ##################################
#ifdef GPU

struct Light
{
	int type;
	float intensity;
	float3 position;
	float3 direction;
};

#ifndef GPU
static float2 canvas_size(600, 600);
static float viewport_size = 1;
static float epsilon = 0.08;
static float3 camera_pos(0, 0, -3);
static float z_near = 1;
static float3 sky_color(0, 0, 0);
static float3 floor_color(1, 1, 1);
static float gamma = 1;
static float exposure = 1;
#endif

struct Intersection
{
	Triangle closest;
	float closest_t;
};

static const float inf = 9999999;

Triangle MakeNull()
{
	Triangle retval;
	retval.a.x = -inf;
	return retval;
}

bool IsNull(Triangle tri)
{
	return tri.a.x == -inf;
}

constant int num_lights = 2;
static Light lights[num_lights];

FUNC Material GetMaterial(int idx)
{
	return materials[idx];
}

FUNC float3 CanvasToViewport(float2 pos)
{
	return float3(pos.x * viewport_size / canvas_size.x,
		pos.y * viewport_size / canvas_size.y,
		z_near);
}

Intersection ClosestIntersection(float3 origin, float3 direction, float min_t, float max_t);
float3 ReflectRay(float3 v1, float3 v2);

#define AMBIENT 0
#define POINT 1

FUNC float3 ComputeLighting(float3 pont, float3 N, float3 V, Material material, float max_t)
{
	float intensity = 0;
	const float length_n = length(N);
	const float length_v = length(V);

	[unroll(num_lights)]
	for (int i = 0; i < num_lights; i++)
	{
		Light light = lights[i];
		if (light.type == AMBIENT)
		{
			intensity += light.intensity;
			continue;
		}

		float3 vec_l;
		if (light.type == POINT)
		{
			vec_l = light.position - pont;
			max_t = 1.0f;
		}
		else // Light.DIRECTIONAL
		{
			vec_l = light.position;
		}

		// Shadow check
		const Intersection intersect = ClosestIntersection(pont, vec_l, epsilon, max_t);
		if (!IsNull(intersect.closest))
			continue;

		// Diffuse
		const float n_dot_l = dot(N, vec_l);
		if (n_dot_l > 0)
		{
			intensity += light.intensity * n_dot_l / (length_n * length(vec_l));
			//intensity += light.intensity * n_dot_l;
		}

		if (material.specular != -1)
		{
			const float3 vec_r = ReflectRay(vec_l, N);
			//const float3 vec_r = mul(2.0*dot(N, vec_l), N) - vec_l;
			const float r_dot_v = dot(vec_r, V);
			if (r_dot_v > 0)
			{
				intensity += light.intensity * pow(r_dot_v / (length(vec_r) * length_v), material.specular);
			}
		}
	}

	return float3(intensity, intensity, intensity);
}

FUNC float2 IntersectRayTriangle(float3 orig, float3 dir, Triangle tri) 
{ 
   	const float3 v0v1 = tri.b - tri.a; 
    const float3 v0v2 = tri.c - tri.a; 
    const float3 pvec = cross(dir, v0v2); 
    const float det = dot(v0v1, pvec); 
 
    // ray and triangle are parallel if det is close to 0
    if (abs(det) < epsilon) return float2(inf, inf); 
 
    const float invDet = 1 / det; 
 
    const float3 tvec = orig - tri.a; 
    const float u = dot(tvec, pvec) * invDet; 
    if (u < 0 || u > 1) return float2(inf, inf); 
 
    const float3 qvec = cross(tvec, v0v1); 
    const float v = dot(dir, qvec) * invDet; 
    if (v < 0 || u + v > 1) return float2(inf, inf); 
 
    const float t = dot(v0v2, qvec) * invDet; 
 
    return (t > 0) ? float2(t, t) : float2(inf, inf); 
} 

FUNC Intersection ClosestIntersection(float3 origin, float3 direction, float min_t, float max_t)
{
	float closest_t = inf;
	Triangle closest_triangle = MakeNull();

//	[unroll(num_triangles)]
	for (int i = 0; i < num_triangles; i++)
	{
		const float2 ts = IntersectRayTriangle(origin, direction, triangles[i]);
		if (ts[0] < closest_t && ts[0] > min_t && ts[0] < max_t)
		{
			closest_t = ts[0];
			closest_triangle = triangles[i];
		}
		if (ts[1] < closest_t && ts[1] > min_t && ts[1] < max_t)
		{
			closest_t = ts[1];
			closest_triangle = triangles[i];
		}
	}

	Intersection retval;
	retval.closest = closest_triangle;
	retval.closest_t = closest_t;

	return retval;
}

FUNC float3 ReflectRay(float3 v1, float3 v2)
{
	return (v2 * ((2.f * dot(v1, v2))) - v1);
}

struct OutRef
{
	float3 ref_color;
	float3 ref_ray;
	float3 ref_point;
	float3 l_color;
	float metal;
	bool end;
};

FUNC float3 RecursiveTraceRay(float3 origin, float3 direction, float min_t, float max_t, int depth)
{
#ifdef REFLECTIONS
	float3 reflected_color;
	float3 reflected_ray = direction;

	OutRef refs[REFLECTION_RECURSION];

	[unroll(REFLECTION_RECURSION)]
	while (depth-- > 0)
	{
		Intersection intersect = ClosestIntersection(origin, reflected_ray, min_t, max_t);
		Triangle closest_triangle = intersect.closest;
		const float closest_t = intersect.closest_t;

		if (IsNull(closest_triangle))
		{
			reflected_color = sky_color;

			refs[depth].ref_color = reflected_color;
			refs[depth].ref_ray = reflected_ray;
			refs[depth].ref_point = origin;
			refs[depth].l_color = reflected_color;
			refs[depth].end = true;
			continue;
		}

		const float3 P = origin + (reflected_ray * closest_t);
		const float3 N = normalize(closest_triangle.normal);

		const float3 view = reflected_ray * -1.f;

		const Material material = GetMaterial(closest_triangle.material_idx);

		const float3 lighting = ComputeLighting(P, N, view, material, inf);
		const float3 local_color = material.color * lighting;

		if (material.metal <= 0 || depth <= 0)
		{
			reflected_color = local_color;

			refs[depth].ref_color = reflected_color;
			refs[depth].ref_ray = reflected_ray;
			refs[depth].ref_point = P;
			refs[depth].l_color = local_color;
			refs[depth].metal = material.metal;
			refs[depth].end = true;
			continue;
		}

		origin = P;
		reflected_ray = ReflectRay(view, N);

		refs[depth].ref_color = reflected_color;
		refs[depth].ref_ray = reflected_ray;
		refs[depth].ref_point = P;
		refs[depth].l_color = local_color;
		refs[depth].metal = material.metal;
		refs[depth].end = false;
	}

	float3 result = refs[REFLECTION_RECURSION - 1].ref_color;
	[unroll(REFLECTION_RECURSION)]
	for (int i = 0; i < REFLECTION_RECURSION; i++)
	{
		if (!refs[i].end)
		{
			result = (refs[i].l_color * (1.f - refs[i].metal)) + (result * refs[i].metal);
		}
		else
		{
			result = refs[i].ref_color;
		}
	}

	return result;
#else
	return sky_color;
#endif
}

FUNC float3 TraceRay(float3 origin, float3 direction, float min_t, float max_t, int depth)
{

	const Intersection intersect = ClosestIntersection(origin, direction, min_t, max_t);
	const Triangle closest_triangle = intersect.closest;
	const float closest_t = intersect.closest_t;

	if (IsNull(closest_triangle))
		return sky_color;

	const float3 P = origin + (direction * closest_t);
	const float3 N = normalize(closest_triangle.normal);

	const float3 view = direction * -1.f;

	const Material material = GetMaterial(closest_triangle.material_idx);

	const float3 lighting = ComputeLighting(P, N, view, material, inf);
	const float3 local_color = material.color * lighting;

#ifndef REFLECTIONS
	return local_color;
#else
	if (material.metal <= 0 || depth <= 0)
	{
		return local_color;
	}

	const float3 reflected_ray = ReflectRay(view, N);
	const float3 result = RecursiveTraceRay(P, reflected_ray, epsilon, inf, depth);

	return (local_color * (1.f - material.metal)) + (result * material.metal);
#endif
}

#ifdef GPU
float4 main(VS_OUTPUT input) : SV_TARGET
#else
FUNC float4 PixelTrace(Input input)
#endif
{
#ifdef GPU
	if (use_cpu)
	{
		float4 color = in_texture.Sample(s0, input.uv);
		return float4(color);
	}
#endif

	lights[0].position = float3(0, 0, 3);
	lights[0].intensity = 0.2;
	lights[0].type = 0;
	lights[1].position = float3(0, 2, 0);
	lights[1].intensity = 0.8;
	lights[1].type = 1;

#ifdef GPU
	const float2 pixel_pos = {(input.pos.x - (canvas_size.x / 2)), (input.pos.y - (canvas_size.y / 2)) * -1};
#else
	const float2 pixel_pos = {input.pos.x, input.pos.y};
#endif

	/*const float pixel_size = 0.25;
	const float3 dir0 = CanvasToViewport(pixel_pos - float2(-pixel_size, -pixel_size));
	const float3 dir1 = CanvasToViewport(pixel_pos - float2(-pixel_size, pixel_size));
	const float3 dir2 = CanvasToViewport(pixel_pos - float2(pixel_size, -pixel_size));
	const float3 dir3 = CanvasToViewport(pixel_pos - float2(pixel_size, pixel_size));

	const float3 color0 = TraceRay(camera_pos, dir0, z_near, inf, REFLECTION_RECURSION);
	const float3 color1 = TraceRay(camera_pos, dir1, z_near, inf, REFLECTION_RECURSION);
	const float3 color2 = TraceRay(camera_pos, dir2, z_near, inf, REFLECTION_RECURSION);
	const float3 color3 = TraceRay(camera_pos, dir3, z_near, inf, REFLECTION_RECURSION);
	float3 color = (color0 + color1 + color2 + color3) / 4;*/
	
	const float3 dir = CanvasToViewport(pixel_pos);
	float3 color = TraceRay(camera_pos, dir, z_near, inf, REFLECTION_RECURSION);

	color = clamp(color * exposure, 0.f, 1.f);
	color.x = pow(color.x, 1.f / gamma);
	color.y = pow(color.y, 1.f / gamma);
	color.z = pow(color.z, 1.f / gamma);

	//return float4(triangles[0].material_idx/2, 0, 0, 1.f);
	return float4(color.x, color.y, color.z, 1.f);
}
// ##################################
#endif


#ifndef GPU
#undef float3
#undef float2
#undef float4
#undef constant
#undef cbuffer
#undef length(v) {}
#undef dot(a, b) {}
#undef normalize(a) {}
#undef clamp

#undef AMBIENT
#undef POINT
#undef FUNC
#endif
