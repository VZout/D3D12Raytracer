#ifndef GPU
#pragma once
#endif

#include "rt_structs.hlsl"

//#define REFLECTIONS
#define USE_BVH
#define REFLECTION_RECURSION 0

#ifdef GPU
Texture2D in_texture : register(t0);
SamplerState s0 : register(s0);

struct VS_OUTPUT
{
	float4 pos : SV_POSITION;
	float2 uv : TEXCOORD;
};
#endif

// ##################################
#ifdef GPU

struct Light
{
	int type;
	float intensity;
	float3 position;
	float3 direction;
};

#ifndef GPU
static float2 canvas_size(600, 600);
static float viewport_size = 1;
static float epsilon = 0.08;
static float3 camera_pos(0, 0, -3);
static float z_near = 1;
static float3 sky_color(0, 0, 0);
static float3 floor_color(1, 1, 1);
static float gamma = 1;
static float exposure = 1;
#endif

struct Intersection
{
	Triangle closest;
	float closest_t;
};

static const float inf = 9999999;

// Load three 16 bit indices from a byte addressed buffer.
uint3 Load3x16BitIndices(uint offsetBytes)
{
    uint3 retval;

    // ByteAdressBuffer loads must be aligned at a 4 byte boundary.
    // Since we need to read three 16 bit indices: { 0, 1, 2 } 
    // aligned at a 4 byte boundary as: { 0 1 } { 2 0 } { 1 2 } { 0 1 } ...
    // we will load 8 bytes (~ 4 indices { a b | c d }) to handle two possible index triplet layouts,
    // based on first index's offsetBytes being aligned at the 4 byte boundary or not:
    //  Aligned:     { 0 1 | 2 - }
    //  Not aligned: { - 0 | 1 2 }
    const uint dwordAlignedOffset = offsetBytes & ~3;    
    const uint2 four16BitIndices = indices.Load2(dwordAlignedOffset);
 
    // Aligned: { 0 1 | 2 - } => retrieve first three 16bit indices
    if (dwordAlignedOffset == offsetBytes)
    {
        retval.x = four16BitIndices.x & 0xffff;
        retval.y = (four16BitIndices.x >> 16) & 0xffff;
        retval.z = four16BitIndices.y & 0xffff;
    }
    else // Not aligned: { - 0 | 1 2 } => retrieve last three 16bit indices
    {
        retval.x = (four16BitIndices.x >> 16) & 0xffff;
        retval.y = four16BitIndices.y & 0xffff;
        retval.z = (four16BitIndices.y >> 16) & 0xffff;
    }

    return retval;
}

constant int num_lights = 2;
static Light lights[num_lights];

FUNC Material GetMaterial(int idx)
{
	return materials[idx];
}

FUNC float3 CanvasToViewport(float2 pos)
{
	return float3(pos.x * viewport_size / canvas_size.x,
		pos.y * viewport_size / canvas_size.y,
		z_near);
}

Intersection ClosestIntersection(float3 origin, float3 direction, float min_t, float max_t);
float3 ReflectRay(float3 v1, float3 v2);

#define AMBIENT 0
#define POINT 1

FUNC float3 ComputeLighting(float3 pont, float3 N, float3 V, Material material, float max_t)
{
	float intensity = 0;
	const float length_n = length(N);
	const float length_v = length(V);

	[unroll(num_lights)]
	for (int i = 0; i < num_lights; i++)
	{
		Light light = lights[i];
		if (light.type == AMBIENT)
		{
			intensity += light.intensity;
			continue;
		}

		float3 vec_l;
		if (light.type == POINT)
		{
			vec_l = light.position - pont;
			max_t = 1.0f;
		}
		else // Light.DIRECTIONAL
		{
			vec_l = light.position;
		}

		// Shadow check
		const Intersection intersect = ClosestIntersection(pont, vec_l, epsilon, max_t);
		if (intersect.closest_t != inf) // if triangle found
			continue;

		// Diffuse
		const float n_dot_l = dot(N, vec_l);
		if (n_dot_l > 0)
		{
			intensity += light.intensity * n_dot_l / (length_n * length(vec_l));
			//intensity += light.intensity * n_dot_l;
		}

		if (material.specular != -1)
		{
			const float3 vec_r = ReflectRay(vec_l, N);
			//const float3 vec_r = mul(2.0*dot(N, vec_l), N) - vec_l;
			const float r_dot_v = dot(vec_r, V);
			if (r_dot_v > 0)
			{
				intensity += light.intensity * pow(r_dot_v / (length(vec_r) * length_v), material.specular);
			}
		}
	}

	return float3(intensity, intensity, intensity);
}

FUNC bool IntersectBVH(float3 orig, float3 dir, BVHNode node)
{
    float tmin, tmax, tymin, tymax, tzmin, tzmax; 
 
	float3 invdir = 1 / dir; 
	int sign[3];
	sign[0] = (invdir.x < 0); 
    sign[1] = (invdir.y < 0); 
    sign[2] = (invdir.z < 0); 

    tmin = (node.bbox[sign[0]].x - orig.x) * invdir.x; 
    tmax = (node.bbox[1-sign[0]].x - orig.x) * invdir.x; 
    tymin = (node.bbox[sign[1]].y - orig.y) * invdir.y; 
    tymax = (node.bbox[1-sign[1]].y - orig.y) * invdir.y; 
 
    if ((tmin > tymax) || (tymin > tmax)) 
        return false; 
    if (tymin > tmin) 
        tmin = tymin; 
    if (tymax < tmax) 
        tmax = tymax; 
 
    tzmin = (node.bbox[sign[2]].z - orig.z) * invdir.z; 
    tzmax = (node.bbox[1-sign[2]].z - orig.z) * invdir.z; 
 
    if ((tmin > tzmax) || (tzmin > tmax)) 
        return false; 
    if (tzmin > tmin) 
        tmin = tzmin; 
    if (tzmax < tmax) 
        tmax = tzmax; 
 
    return true; 
}

FUNC float2 IntersectRayTriangle(float3 orig, float3 dir, Triangle tri) 
{ 
   	const float3 v0v1 = tri.b - tri.a; 
    const float3 v0v2 = tri.c - tri.a; 
    const float3 pvec = cross(dir, v0v2); 
    const float det = dot(v0v1, pvec); 
 
    // ray and triangle are parallel if det is close to 0
    if (abs(det) < epsilon) return float2(inf, inf); 
 
    const float invDet = 1 / det; 
 
    const float3 tvec = orig - tri.a; 
    const float u = dot(tvec, pvec) * invDet; 
    if (u < 0 || u > 1) return float2(inf, inf); 
 
    const float3 qvec = cross(tvec, v0v1); 
    const float v = dot(dir, qvec) * invDet; 
    if (v < 0 || u + v > 1) return float2(inf, inf); 
 
    const float t = dot(v0v2, qvec) * invDet; 
 
    return (t > 0) ? float2(t, t) : float2(inf, inf); 
} 

FUNC Intersection ClosestIntersection(float3 origin, float3 direction, float min_t, float max_t)
{
	float closest_t = inf;
	Triangle closest_triangle;

	int bvh_num_indices = -1;
	int indices_start = -1;
	
#ifdef USE_BVH
	int left_child = -1;

	// Intersect root node.
	if (IntersectBVH(origin, direction, bvh_nodes[0]))
	{
		left_child = bvh_nodes[0].left_first;
	}
	else // no bvh intersections found
	{
		Intersection retval;
		retval.closest = closest_triangle;
		retval.closest_t = closest_t;
		return retval;
	}

	// Recursivily intersect childeren
	while(bvh_num_indices == -1) // while no end node has been found and it didn't completely miss.
	{
		const BVHNode left_node = bvh_nodes[left_child];
		const BVHNode right_node = bvh_nodes[left_child + 1];

		const bool left = IntersectBVH(origin, direction, left_node);
		const bool right = IntersectBVH(origin, direction, right_node);

		if (left)
		{
			if (left_node.num_indices == -1) // if is not a end node
			{
				left_child = left_node.left_first;
			}
			else { // is a end node.
				bvh_num_indices = left_node.num_indices;
				indices_start = left_node.bib_start;
			}
		}
		else if(right)
		{
			if (right_node.num_indices == -1) // if is not a end node
			{
				left_child = right_node.left_first;
			}
			else { // is a end node.
				bvh_num_indices = right_node.num_indices;
				indices_start = right_node.bib_start;
			}
		}
		else {
			// Becasue hlsl is garbage?
			/*closest_triangle.a = float3(0, 0, 0);
			closest_triangle.b = float3(0, 0, 0);
			closest_triangle.c = float3(0, 0, 0);
			closest_triangle.normal = float3(0, 0, 0);
			closest_triangle.material_idx = 0;
			closest_triangle.u = 0;
			closest_triangle.v = 0;
			closest_triangle.padding3 = 0;

			Intersection intersection;
			intersection.closest = closest_triangle;
			intersection.closest_t = closest_t;
			return intersection;*/
			break; // missed
		}

		// hit multiple bvh's. Using both in this case.
		if (left && right)
		{
			if (left_node.bib_start < right_node.bib_start) {
				indices_start = left_node.bib_start;
				bvh_num_indices = right_node.num_indices;
			}
			else
			{
				indices_start = right_node.bib_start;
				bvh_num_indices = left_node.num_indices;
			}
		}
	}
#else
	bvh_num_indices = num_indices;
	indices_start = 0;
#endif

	for (int i = indices_start; i < bvh_num_indices; i += 3)
	{
		const uint3 tri_vertices = Load3x16BitIndices(i*2);
		const Vertex v0 = vertices[tri_vertices.x];
		const Vertex v1 = vertices[tri_vertices.y];
		const Vertex v2 = vertices[tri_vertices.z];

		Triangle tri;
		tri.a = v0.position;
		tri.b = v1.position;
		tri.c = v2.position;
		tri.normal = normalize(v0.normal + v1.normal + v2.normal);
		tri.material_idx = v1.material_idx;
		

		const float2 ts = IntersectRayTriangle(origin, direction, tri);
		if (ts[0] < closest_t && ts[0] > min_t && ts[0] < max_t)
		{
			closest_t = ts[0];
			closest_triangle = tri;
		}
		if (ts[1] < closest_t && ts[1] > min_t && ts[1] < max_t)
		{
			closest_t = ts[1];
			closest_triangle = tri;
		}
	}

	Intersection retval;
	retval.closest = closest_triangle;
	retval.closest_t = closest_t;

	return retval;
}

FUNC float3 ReflectRay(float3 v1, float3 v2)
{
	return (v2 * ((2.f * dot(v1, v2))) - v1);
}

struct OutRef
{
	float3 ref_color;
	float3 ref_ray;
	float3 ref_point;
	float3 l_color;
	float metal;
	bool end;
};

FUNC float3 RecursiveTraceRay(float3 origin, float3 direction, float min_t, float max_t, int depth)
{
#ifdef REFLECTIONS
	float3 reflected_color;
	float3 reflected_ray = direction;

	OutRef refs[REFLECTION_RECURSION];

	[unroll(REFLECTION_RECURSION)]
	while (depth-- > 0)
	{
		Intersection intersect = ClosestIntersection(origin, reflected_ray, min_t, max_t);
		Triangle closest_triangle = intersect.closest;
		const float closest_t = intersect.closest_t;

		if (intersect.closest_t == inf) // if no triangle found
		{
			reflected_color = sky_color;

			refs[depth].ref_color = reflected_color;
			refs[depth].ref_ray = reflected_ray;
			refs[depth].ref_point = origin;
			refs[depth].l_color = reflected_color;
			refs[depth].end = true;
			continue;
		}

		const float3 P = origin + (reflected_ray * closest_t);
		const float3 N = normalize(closest_triangle.normal);

		const float3 view = reflected_ray * -1.f;

		const Material material = GetMaterial(closest_triangle.material_idx);

		const float3 lighting = ComputeLighting(P, N, view, material, inf);
		const float3 local_color = material.color * lighting;

		if (material.metal <= 0 || depth <= 0)
		{
			reflected_color = local_color;

			refs[depth].ref_color = reflected_color;
			refs[depth].ref_ray = reflected_ray;
			refs[depth].ref_point = P;
			refs[depth].l_color = local_color;
			refs[depth].metal = material.metal;
			refs[depth].end = true;
			continue;
		}

		origin = P;
		reflected_ray = ReflectRay(view, N);

		refs[depth].ref_color = reflected_color;
		refs[depth].ref_ray = reflected_ray;
		refs[depth].ref_point = P;
		refs[depth].l_color = local_color;
		refs[depth].metal = material.metal;
		refs[depth].end = false;
	}

	float3 result = refs[REFLECTION_RECURSION - 1].ref_color;
	[unroll(REFLECTION_RECURSION)]
	for (int i = 0; i < REFLECTION_RECURSION; i++)
	{
		if (!refs[i].end)
		{
			result = (refs[i].l_color * (1.f - refs[i].metal)) + (result * refs[i].metal);
		}
		else
		{
			result = refs[i].ref_color;
		}
	}

	return result;
#else
	return sky_color;
#endif
}

FUNC float3 TraceRay(float3 origin, float3 direction, float min_t, float max_t, int depth)
{
	const Intersection intersect = ClosestIntersection(origin, direction, min_t, max_t);
	const Triangle closest_triangle = intersect.closest;
	const float closest_t = intersect.closest_t;

	if (closest_t == inf) // if no triangle found
		return sky_color;

	const float3 P = origin + (direction * closest_t);
	const float3 N = normalize(closest_triangle.normal);

	const float3 view = direction * -1.f;

	const Material material = GetMaterial(closest_triangle.material_idx);

	const float3 lighting = ComputeLighting(P, N, view, material, inf);
	const float3 local_color = material.color * lighting;

#ifndef REFLECTIONS
	return local_color;
#else
	if (material.metal <= 0 || depth <= 0)
	{
		return local_color;
	}

	const float3 reflected_ray = ReflectRay(view, N);
	const float3 result = RecursiveTraceRay(P, reflected_ray, epsilon, inf, depth);

	return (local_color * (1.f - material.metal)) + (result * material.metal);
#endif
}

#ifdef GPU
float4 main(VS_OUTPUT input) : SV_TARGET
#else
FUNC float4 PixelTrace(Input input)
#endif
{
#ifdef GPU
	if (use_cpu)
	{
		float4 color = in_texture.Sample(s0, input.uv);
		return float4(color);
	}
#endif

	lights[0].position = float3(0, 0, 3);
	lights[0].intensity = 0.2;
	lights[0].type = 0;
	lights[1].position = float3(0, 2, 0);
	lights[1].intensity = 0.8;
	lights[1].type = 1;

#ifdef GPU
	const float2 pixel_pos = {(input.pos.x - (canvas_size.x / 2)), (input.pos.y - (canvas_size.y / 2)) * -1};
#else
	const float2 pixel_pos = {input.pos.x, input.pos.y};
#endif

	/*const float pixel_size = 0.25;
	const float3 dir0 = CanvasToViewport(pixel_pos - float2(-pixel_size, -pixel_size));
	const float3 dir1 = CanvasToViewport(pixel_pos - float2(-pixel_size, pixel_size));
	const float3 dir2 = CanvasToViewport(pixel_pos - float2(pixel_size, -pixel_size));
	const float3 dir3 = CanvasToViewport(pixel_pos - float2(pixel_size, pixel_size));

	const float3 color0 = TraceRay(camera_pos, dir0, z_near, inf, REFLECTION_RECURSION);
	const float3 color1 = TraceRay(camera_pos, dir1, z_near, inf, REFLECTION_RECURSION);
	const float3 color2 = TraceRay(camera_pos, dir2, z_near, inf, REFLECTION_RECURSION);
	const float3 color3 = TraceRay(camera_pos, dir3, z_near, inf, REFLECTION_RECURSION);
	float3 color = (color0 + color1 + color2 + color3) / 4;*/
	
	const float3 dir = CanvasToViewport(pixel_pos);
	float3 color = TraceRay(camera_pos, dir, z_near, inf, REFLECTION_RECURSION);

	color = clamp(color * exposure, 0.f, 1.f);
	color.x = pow(color.x, 1.f / gamma);
	color.y = pow(color.y, 1.f / gamma);
	color.z = pow(color.z, 1.f / gamma);

	//return float4(bvh_right_hits, bvh_left_hits, 0, 1.f);
	return float4(color.x, color.y, color.z, 1.f);
}
// ##################################
#endif


#ifndef GPU
#undef float3
#undef float2
#undef float4
#undef constant
#undef cbuffer
#undef length(v) {}
#undef dot(a, b) {}
#undef normalize(a) {}
#undef clamp

#undef AMBIENT
#undef POINT
#undef FUNC
#endif
